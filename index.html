
<!DOCTYPE html>
<html>
<head>
  <title>Bike Route Planner</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }
    h1 {
      color: white;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .container {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      max-width: 1400px;
      margin: 0 auto;
    }
    .map-container {
      flex: 2;
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      padding: 15px;
    }
    .sidebar {
      flex: 1;
      min-width: 320px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      padding: 20px;
    }
    #map {
      height: 500px;
      width: 100%;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.1);
    }
    #route-list {
      margin-top: 15px;
      border: 1px solid #e0e0e0;
      padding: 15px;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      border-radius: 8px;
      max-height: 200px;
      overflow-y: auto;
    }
    #error-message {
      color: #e74c3c;
      margin: 10px 0;
      display: none;
      padding: 10px;
      background: #fdf2f2;
      border: 1px solid #fecaca;
      border-radius: 6px;
    }
    .route-segment {
      cursor: pointer;
    }
    .segment-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #ddd;
      transition: background-color 0.2s;
    }
    .segment-item:hover {
      background-color: rgba(255,255,255,0.5);
      border-radius: 4px;
      padding-left: 4px;
    }
    .remove-btn {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      color: white;
      border: none;
      padding: 4px 10px;
      border-radius: 15px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.2s;
      box-shadow: 0 2px 8px rgba(238,90,82,0.3);
    }
    .remove-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(238,90,82,0.4);
    }
    .action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    #download-gpx {
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
      box-shadow: 0 4px 16px rgba(76,175,80,0.3);
      flex: 1;
    }
    #download-gpx:disabled {
      background: #cccccc;
      cursor: not-allowed;
      box-shadow: none;
    }
    #download-gpx:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(76,175,80,0.4);
    }
    .undo-btn {
      background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
      color: white;
      border: none;
      padding: 12px 16px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
      box-shadow: 0 4px 16px rgba(255,152,0,0.3);
      min-width: 60px;
    }
    .undo-btn:disabled {
      background: #cccccc;
      cursor: not-allowed;
      box-shadow: none;
    }
    .undo-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(255,152,0,0.4);
    }
    .mapboxgl-popup.segment-tooltip .mapboxgl-popup-content {
      background-color: rgba(0, 0, 0, 0.9);
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 13px;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      pointer-events: none;
    }
    .mapboxgl-popup.segment-tooltip .mapboxgl-popup-tip {
      border-top-color: rgba(0, 0, 0, 0.9);
    }
    .search-container {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
    }
    #location-search {
      flex: 1;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 25px;
      font-size: 14px;
      transition: border-color 0.2s;
    }
    #location-search:focus {
      outline: none;
      border-color: #2196F3;
    }
    #search-btn {
      background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 25px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s;
      box-shadow: 0 4px 16px rgba(33,150,243,0.3);
    }
    #search-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 20px rgba(33,150,243,0.4);
    }
    .leaflet-interactive {
      outline: none !important;
    }
    .leaflet-interactive:focus {
      outline: none !important;
    }
    h3 {
      color: #333;
      margin-top: 0;
      margin-bottom: 15px;
      font-size: 1.2em;
      font-weight: 600;
    }
    #route-description {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      font-size: 14px;
      line-height: 1.4;
    }
    .file-upload-container {
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
    }
    #kml-file {
      margin-bottom: 10px;
      padding: 10px;
      border: 2px dashed #ddd;
      border-radius: 8px;
      width: 100%;
      cursor: pointer;
    }
    #kml-file:hover {
      border-color: #2196F3;
    }
  </style>
</head>
<body>

  <h1>üö¥‚Äç‚ôÇÔ∏è Bike Route Planner</h1>

  <div id="error-message"></div>
  
  

  <div class="container">
    <div class="map-container">
      <div id="map"></div>
    </div>
    
    <div class="sidebar">
      <h3>Search Location</h3>
      <div class="search-container">
        <input type="text" id="location-search" placeholder="Enter a place name..." />
        <button id="search-btn">Search</button>
      </div>
      <div id="search-error" style="color: red; font-size: 12px; margin-top: 5px; display: none;"></div>
      
      <h3>Selected Route Segments</h3>
      <div id="route-list">
        <p style="color: #666; font-style: italic;">No segments selected. Click on route segments on the map to add them to your route.</p>
      </div>

      <h3>Route Description</h3>
      <div id="route-description">Click on map segments to build your route.</div>

      <div class="action-buttons">
        <button id="undo-btn" class="undo-btn" disabled title="Undo (Ctrl+Z)">‚Ü∂</button>
        <button id="redo-btn" class="undo-btn" disabled title="Redo (Ctrl+Shift+Z)">‚Ü∑</button>
        <button id="download-gpx" disabled>Download GPX Route</button>
      </div>
    </div>
  </div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
  <script>
    let map;
    let selectedSegments = [];
    let routePolylines = [];
    let undoStack = [];
    let redoStack = [];
    let kmlData = null;
    
    // Save state for undo/redo
    function saveState() {
      undoStack.push([...selectedSegments]);
      redoStack = []; // Clear redo stack when new action is performed
      updateUndoRedoButtons();
    }
    
    function undo() {
      if (undoStack.length > 0) {
        redoStack.push([...selectedSegments]);
        selectedSegments = undoStack.pop();
        updateSegmentStyles();
        updateRouteListAndDescription();
        updateUndoRedoButtons();
      }
    }
    
    function redo() {
      if (redoStack.length > 0) {
        undoStack.push([...selectedSegments]);
        selectedSegments = redoStack.pop();
        updateSegmentStyles();
        updateRouteListAndDescription();
        updateUndoRedoButtons();
      }
    }
    
    function updateUndoRedoButtons() {
      document.getElementById('undo-btn').disabled = undoStack.length === 0;
      document.getElementById('redo-btn').disabled = redoStack.length === 0;
    }
    
    function updateSegmentStyles() {
      routePolylines.forEach(polylineData => {
        const layerId = polylineData.layerId;
        if (selectedSegments.includes(polylineData.segmentName)) {
          map.setPaintProperty(layerId, 'line-color', '#00ff00');
          map.setPaintProperty(layerId, 'line-width', polylineData.originalStyle.weight + 1);
        } else {
          map.setPaintProperty(layerId, 'line-color', polylineData.originalStyle.color);
          map.setPaintProperty(layerId, 'line-width', polylineData.originalStyle.weight);
        }
      });
    }

    function initMap() {
      try {
        mapboxgl.accessToken = 'pk.eyJ1Ijoib3NlcmZhdHkiLCJhIjoiY21kNmdzb3NnMDlqZTJrc2NzNmh3aGk1aCJ9.dvA6QY0N5pQ2IISZHp53kg';
        
        map = new mapboxgl.Map({
          container: 'map',
          style: 'mapbox://styles/mapbox/outdoors-v12',
          center: [35.6, 33.2], // Centered on the bike routes area
          zoom: 11
        });

        map.on('load', () => {
          loadKMLFile();
        });

        // Add global click handler for proximity-based selection
        map.on('click', (e) => {
          const clickPoint = e.lngLat;
          const threshold = 50; // meters
          let closestSegment = null;
          let minDistance = Infinity;
          
          // Find closest segment within threshold
          routePolylines.forEach(polylineData => {
            const coords = polylineData.coordinates;
            for (let i = 0; i < coords.length - 1; i++) {
              const distance = distanceToLineSegment(
                { lat: clickPoint.lat, lng: clickPoint.lng },
                coords[i],
                coords[i + 1]
              );
              
              if (distance < threshold && distance < minDistance) {
                minDistance = distance;
                closestSegment = polylineData;
              }
            }
          });
          
          // Select/deselect closest segment if found
          if (closestSegment) {
            const name = closestSegment.segmentName;
            const layerId = closestSegment.layerId;
            
            if (!selectedSegments.includes(name)) {
              saveState();
              selectedSegments.push(name);
              map.setPaintProperty(layerId, 'line-color', '#00ff00');
              map.setPaintProperty(layerId, 'line-width', closestSegment.originalStyle.weight + 1);
              
              // Smart focusing logic (same as before)
              if (closestSegment.coordinates.length > 0 && selectedSegments.length > 1) {
                const previousSegmentName = selectedSegments[selectedSegments.length - 2];
                const previousPolyline = routePolylines.find(p => p.segmentName === previousSegmentName);
                
                if (previousPolyline) {
                  const prevCoords = previousPolyline.coordinates;
                  const prevStart = prevCoords[0];
                  const prevEnd = prevCoords[prevCoords.length - 1];
                  
                  const currentStart = closestSegment.coordinates[0];
                  const currentEnd = closestSegment.coordinates[closestSegment.coordinates.length - 1];
                  
                  const prevEndToCurrentStart = getDistance(prevEnd, currentStart);
                  const prevEndToCurrentEnd = getDistance(prevEnd, currentEnd);
                  const prevStartToCurrentStart = getDistance(prevStart, currentStart);
                  const prevStartToCurrentEnd = getDistance(prevStart, currentEnd);
                  
                  const minDistance = Math.min(prevEndToCurrentStart, prevEndToCurrentEnd, prevStartToCurrentStart, prevStartToCurrentEnd);
                  
                  let focusPoint;
                  if (minDistance === prevEndToCurrentStart) {
                    focusPoint = [currentEnd.lng, currentEnd.lat];
                  } else if (minDistance === prevEndToCurrentEnd) {
                    focusPoint = [currentStart.lng, currentStart.lat];
                  } else if (minDistance === prevStartToCurrentStart) {
                    focusPoint = [currentEnd.lng, currentEnd.lat];
                  } else {
                    focusPoint = [currentStart.lng, currentStart.lat];
                  }
                  
                  map.panTo(focusPoint, {
                    duration: 1000
                  });
                }
              }
            } else {
              saveState();
              const index = selectedSegments.indexOf(name);
              selectedSegments.splice(index, 1);
              map.setPaintProperty(layerId, 'line-color', closestSegment.originalStyle.color);
              map.setPaintProperty(layerId, 'line-width', closestSegment.originalStyle.weight);
            }
            updateRouteListAndDescription();
          }
        });
        
      } catch (error) {
        document.getElementById('error-message').style.display = 'block';
        document.getElementById('error-message').textContent = 'Error loading map: ' + error.message;
      }
    }

    async function loadKMLFile() {
      try {
        const response = await fetch('./bike_roads_v01.geojson');
        const geoJsonData = await response.json();
        parseGeoJSON(geoJsonData);
      } catch (error) {
        document.getElementById('error-message').style.display = 'block';
        document.getElementById('error-message').textContent = 'Error loading GeoJSON file: ' + error.message;
      }
    }

    function parseGeoJSON(geoJsonData) {
      try {
        kmlData = JSON.stringify(geoJsonData);
        
        if (!geoJsonData.features || geoJsonData.features.length === 0) {
          document.getElementById('error-message').style.display = 'block';
          document.getElementById('error-message').textContent = 'No route segments found in the GeoJSON file.';
          return;
        }
        
        document.getElementById('error-message').style.display = 'none';

        // Clear existing layers and sources
        routePolylines.forEach(polylineData => {
          if (map.getLayer(polylineData.layerId)) {
            map.removeLayer(polylineData.layerId);
          }
          if (map.getSource(polylineData.layerId)) {
            map.removeSource(polylineData.layerId);
          }
        });
        routePolylines = [];

        let bounds = new mapboxgl.LngLatBounds();

        geoJsonData.features.forEach(feature => {
          if (feature.geometry.type !== 'LineString') return;
          
          const name = feature.properties.name || 'Unnamed Route';
          const coordinates = feature.geometry.coordinates;
          
          // Convert coordinates from [lng, lat] to {lat, lng} objects for distance calculations
          const coordObjects = coordinates.map(coord => ({
            lat: coord[1],
            lng: coord[0]
          }));

          // Extract style information from properties
          let originalColor = feature.properties.stroke || feature.properties['stroke-color'] || '#0288d1';
          let originalWeight = feature.properties['stroke-width'] || 3;
          let originalOpacity = feature.properties['stroke-opacity'] || 0.8;

          const layerId = `route-${name.replace(/\s+/g, '-').replace(/[^\w-]/g, '')}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          
          // Add source and layer to map
          map.addSource(layerId, {
            type: 'geojson',
            data: feature
          });

          map.addLayer({
            id: layerId,
            type: 'line',
            source: layerId,
            layout: {
              'line-join': 'round',
              'line-cap': 'round'
            },
            paint: {
              'line-color': originalColor,
              'line-width': originalWeight,
              'line-opacity': originalOpacity
            }
          });

          // Store polyline data
          const polylineData = {
            segmentName: name,
            layerId: layerId,
            coordinates: coordObjects,
            originalStyle: {
              color: originalColor,
              weight: originalWeight,
              opacity: originalOpacity
            }
          };
          routePolylines.push(polylineData);

          // Add coordinates to bounds for auto-fitting
          coordinates.forEach(coord => bounds.extend(coord));

          // Add click event listener
          map.on('click', layerId, (e) => {
            if (!selectedSegments.includes(name)) {
              // Save state before making changes
              saveState();
              // Add segment to selection
              selectedSegments.push(name);
              map.setPaintProperty(layerId, 'line-color', '#00ff00');
              map.setPaintProperty(layerId, 'line-width', originalWeight + 1);
              
              // Smart focusing based on route direction
              if (coordObjects.length > 0 && selectedSegments.length > 1) {
                // Find the previously selected segment
                const previousSegmentName = selectedSegments[selectedSegments.length - 2];
                const previousPolyline = routePolylines.find(p => p.segmentName === previousSegmentName);
                
                if (previousPolyline) {
                  const prevCoords = previousPolyline.coordinates;
                  const prevStart = prevCoords[0];
                  const prevEnd = prevCoords[prevCoords.length - 1];
                  
                  const currentStart = coordObjects[0];
                  const currentEnd = coordObjects[coordObjects.length - 1];
                  
                  // Calculate distances between endpoints
                  const prevEndToCurrentStart = getDistance(prevEnd, currentStart);
                  const prevEndToCurrentEnd = getDistance(prevEnd, currentEnd);
                  const prevStartToCurrentStart = getDistance(prevStart, currentStart);
                  const prevStartToCurrentEnd = getDistance(prevStart, currentEnd);
                  
                  // Find the minimum distance to determine connection
                  const minDistance = Math.min(prevEndToCurrentStart, prevEndToCurrentEnd, prevStartToCurrentStart, prevStartToCurrentEnd);
                  
                  let focusPoint;
                  if (minDistance === prevEndToCurrentStart) {
                    focusPoint = [currentEnd.lng, currentEnd.lat];
                  } else if (minDistance === prevEndToCurrentEnd) {
                    focusPoint = [currentStart.lng, currentStart.lat];
                  } else if (minDistance === prevStartToCurrentStart) {
                    focusPoint = [currentEnd.lng, currentEnd.lat];
                  } else {
                    focusPoint = [currentStart.lng, currentStart.lat];
                  }
                  
                  // Use smooth panning
                  map.panTo(focusPoint, {
                    duration: 1000
                  });
                }
              }
            } else {
              // Save state before making changes
              saveState();
              // Remove segment from selection
              const index = selectedSegments.indexOf(name);
              selectedSegments.splice(index, 1);
              map.setPaintProperty(layerId, 'line-color', originalColor);
              map.setPaintProperty(layerId, 'line-width', originalWeight);
            }
            updateRouteListAndDescription();
          });

          // Add hover effects with tooltip
          map.on('mouseenter', layerId, (e) => {
            map.getCanvas().style.cursor = 'pointer';
            if (!selectedSegments.includes(name)) {
              map.setPaintProperty(layerId, 'line-width', originalWeight + 2);
              map.setPaintProperty(layerId, 'line-opacity', 1);
            }
            
            // Create and show tooltip
            const tooltip = new mapboxgl.Popup({
              closeButton: false,
              closeOnClick: false,
              className: 'segment-tooltip'
            })
            .setLngLat(e.lngLat)
            .setHTML(`<div>${name}</div>`)
            .addTo(map);
            
            // Store tooltip reference for cleanup
            map._currentTooltip = tooltip;
          });

          map.on('mouseleave', layerId, () => {
            map.getCanvas().style.cursor = '';
            if (!selectedSegments.includes(name)) {
              map.setPaintProperty(layerId, 'line-width', originalWeight);
              map.setPaintProperty(layerId, 'line-opacity', originalOpacity);
            }
            
            // Remove tooltip
            if (map._currentTooltip) {
              map._currentTooltip.remove();
              map._currentTooltip = null;
            }
          });

          map.on('mousemove', layerId, (e) => {
            if (map._currentTooltip) {
              map._currentTooltip.setLngLat(e.lngLat);
            }
          });
        });

        // Fit map to show all route segments
        if (!bounds.isEmpty()) {
          map.fitBounds(bounds, { padding: 20 });
        }

      } catch (error) {
        document.getElementById('error-message').style.display = 'block';
        document.getElementById('error-message').textContent = 'Error parsing GeoJSON file: ' + error.message;
      }
    }

    // Helper function to calculate distance between two points
    function getDistance(point1, point2) {
      const R = 6371e3; // Earth's radius in meters
      const œÜ1 = point1.lat * Math.PI/180;
      const œÜ2 = point2.lat * Math.PI/180;
      const ŒîœÜ = (point2.lat-point1.lat) * Math.PI/180;
      const ŒîŒª = (point2.lng-point1.lng) * Math.PI/180;

      const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                Math.cos(œÜ1) * Math.cos(œÜ2) *
                Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

      return R * c;
    }

    // Helper function to calculate distance from point to line segment
    function distanceToLineSegment(point, lineStart, lineEnd) {
      const A = point.lng - lineStart.lng;
      const B = point.lat - lineStart.lat;
      const C = lineEnd.lng - lineStart.lng;
      const D = lineEnd.lat - lineStart.lat;

      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      if (lenSq !== 0) {
        param = dot / lenSq;
      }

      let xx, yy;
      if (param < 0) {
        xx = lineStart.lng;
        yy = lineStart.lat;
      } else if (param > 1) {
        xx = lineEnd.lng;
        yy = lineEnd.lat;
      } else {
        xx = lineStart.lng + param * C;
        yy = lineStart.lat + param * D;
      }

      return getDistance(point, { lat: yy, lng: xx });
    }

    function updateRouteListAndDescription() {
      const routeList = document.getElementById('route-list');
      const routeDescription = document.getElementById('route-description');
      const downloadButton = document.getElementById('download-gpx');

      if (selectedSegments.length === 0) {
        routeList.innerHTML = '<p style="color: #666; font-style: italic;">No segments selected. Click on route segments on the map to add them to your route.</p>';
        routeDescription.textContent = 'Click on map segments to build your route.';
        downloadButton.disabled = true;
        return;
      }

      routeList.innerHTML = '';
      selectedSegments.forEach((segmentName, index) => {
        const segmentDiv = document.createElement('div');
        segmentDiv.className = 'segment-item';
        segmentDiv.innerHTML = `
          <span><strong>${index + 1}.</strong> ${segmentName}</span>
          <button class="remove-btn" onclick="removeSegment('${segmentName}')">Remove</button>
        `;
        routeList.appendChild(segmentDiv);
      });

      // Calculate total distance and elevation gain
      let totalDistance = 0;
      let totalElevationGain = 0;
      
      selectedSegments.forEach(segmentName => {
        const polyline = routePolylines.find(p => p.segmentName === segmentName);
        if (polyline && polyline.coordinates) {
          // Calculate distance for this segment
          for (let i = 0; i < polyline.coordinates.length - 1; i++) {
            const distance = getDistance(polyline.coordinates[i], polyline.coordinates[i + 1]);
            totalDistance += distance;
          }
          
          // Calculate elevation gain (simulated - you can replace with real elevation data)
          // For now, we'll estimate based on segment length and assume some elevation change
          const segmentLength = polyline.coordinates.length;
          const estimatedElevationGain = segmentLength * 0.5; // Rough estimate
          totalElevationGain += estimatedElevationGain;
        }
      });
      
      const totalDistanceKm = (totalDistance / 1000).toFixed(1);
      const totalElevationM = Math.round(totalElevationGain);
      
      routeDescription.innerHTML = `
        <strong>Route Summary:</strong><br>
        ${selectedSegments.length} segment${selectedSegments.length > 1 ? 's' : ''} selected<br>
        <strong>üìè Distance:</strong> ${totalDistanceKm} km<br>
        <strong>‚õ∞Ô∏è Elevation Gain:</strong> ${totalElevationM} m<br>
        <small style="color: #333; margin-top: 8px; display: block;">${selectedSegments.join(' ‚Üí ')}</small>
      `;
      
      downloadButton.disabled = false;
    }

    function removeSegment(segmentName) {
      const index = selectedSegments.indexOf(segmentName);
      if (index > -1) {
        saveState();
        selectedSegments.splice(index, 1);
        
        // Reset polyline to original style
        const polyline = routePolylines.find(p => p.segmentName === segmentName);
        if (polyline) {
          polyline.setStyle(polyline.originalStyle);
        }
        
        updateRouteListAndDescription();
      }
    }

    document.getElementById('download-gpx').addEventListener('click', () => {
      if (!kmlData) return;
      
      const geoJsonData = JSON.parse(kmlData);

      let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="BikeRoutePlanner" xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <trk>
    <name>Planned Bike Route</name>
    <trkseg>`;

      selectedSegments.forEach(segmentName => {
        const feature = geoJsonData.features.find(f => 
          (f.properties.name || 'Unnamed Route') === segmentName
        );
        
        if (feature && feature.geometry.type === 'LineString') {
          feature.geometry.coordinates.forEach(coord => {
            const [lng, lat] = coord;
            gpx += `
      <trkpt lat="${lat}" lon="${lng}"></trkpt>`;
          });
        }
      });

      gpx += `
    </trkseg>
  </trk>
</gpx>`;

      const blob = new Blob([gpx], {type: 'application/gpx+xml'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'bike_route.gpx';
      a.click();
      URL.revokeObjectURL(url);
    });

    // Search functionality
    function searchLocation() {
      const searchInput = document.getElementById('location-search');
      const searchError = document.getElementById('search-error');
      const query = searchInput.value.trim();
      
      if (!query) {
        searchError.textContent = 'Please enter a location to search';
        searchError.style.display = 'block';
        return;
      }
      
      searchError.style.display = 'none';
      
      // Use Nominatim (OpenStreetMap) geocoding service
      const geocodeUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`;
      
      fetch(geocodeUrl)
        .then(response => response.json())
        .then(data => {
          if (data && data.length > 0) {
            const result = data[0];
            const lat = parseFloat(result.lat);
            const lon = parseFloat(result.lon);
            
            // Only pan to the location without showing markers or popups
            const zoomLevel = result.type === 'city' ? 12 : 
                            result.type === 'town' ? 13 : 
                            result.type === 'village' ? 14 : 13;
            
            map.flyTo({
              center: [lon, lat],
              zoom: zoomLevel,
              duration: 1000
            });
            
            searchInput.value = '';
          } else {
            searchError.textContent = 'Location not found. Please try a different search term.';
            searchError.style.display = 'block';
          }
        })
        .catch(error => {
          console.error('Search error:', error);
          searchError.textContent = 'Error searching for location. Please try again.';
          searchError.style.display = 'block';
        });
    }
    
    // Add event listeners for search
    document.getElementById('search-btn').addEventListener('click', searchLocation);
    document.getElementById('location-search').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        searchLocation();
      }
    });

    // Add event listeners for undo/redo buttons
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('redo-btn').addEventListener('click', redo);

    // Add keyboard shortcuts for undo/redo
    document.addEventListener('keydown', function(e) {
      if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      } else if (e.ctrlKey && e.shiftKey && e.key === 'Z') {
        e.preventDefault();
        redo();
      }
    });

    // Initialize the map when page loads
    initMap();
  </script>
</body>
</html>
